/**
 * Generated file: embedded static assets
 * DO NOT EDIT - This file is auto-generated by scripts/generate-assets.js
 */

export const MIME_TYPES: Record<string, string> = {
  '.html': 'text/html',
  '.css': 'text/css',
  '.js': 'text/javascript',
  '.json': 'application/json',
};

// Embedded assets as string literals
export const EMBEDDED_ASSETS: Record<string, string> = {
  'index.html': `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Classifier</title>
    <link rel="stylesheet" href="/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/lib/marked.umd.js"></script>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">üìÅ Data Classifier - <span id="filename">Loading...</span> (<span id="progress">0/0</span>)</h1>
            <div class="mode-indicator">
                <span id="markdown-indicator" class="mode-badge hidden">üìù Markdown</span>
            </div>
        </header>

        <main class="content">
            <div id="content-display" class="content-display">
                <div class="loading">Loading content...</div>
            </div>
        </main>

        <section class="status">
            <div class="status-indicator">
                Status: <span id="classification-status" class="status-text">‚ö™ Unclassified</span>
            </div>
            <div id="comment-display" class="comment-display hidden"></div>
        </section>

        <section class="controls">
            <div id="category-buttons" class="category-buttons">
                <!-- Dynamically generated category buttons -->
            </div>
        </section>

        <footer class="navigation">
            <div class="nav-controls">
                <button id="prev-btn" class="nav-btn" disabled>‚Üê Prev</button>
                <span id="nav-progress" class="nav-progress">0/0</span>
                <button id="next-btn" class="nav-btn" disabled>Next ‚Üí</button>
                <button id="comment-btn" class="nav-btn comment-btn" title="Add/edit comment (M)">üí¨</button>
            </div>
            <div class="stats">
                <span id="stats-classified" class="stat">‚úÖ0</span>
                <span id="stats-skipped" class="stat">‚è≠0</span>
                <span id="stats-remaining" class="stat">‚è≥0</span>
            </div>
        </footer>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="help-modal hidden">
        <div class="help-overlay" id="help-overlay"></div>
        <div class="help-content">
            <div class="help-header">
                <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
                <button id="help-close" class="help-close">√ó</button>
            </div>
            <div class="help-body">
                <div class="help-section">
                    <h3>üè∑Ô∏è Classification</h3>
                    <div class="shortcut-list">
                        <div class="shortcut-item">
                            <kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd> ... <kbd>9</kbd>
                            <span>Classify with category 1-9</span>
                        </div>
                    </div>
                </div>

                <div class="help-section">
                    <h3>üß≠ Navigation</h3>
                    <div class="shortcut-list">
                        <div class="shortcut-item">
                            <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> or <kbd>J</kbd> <kbd>K</kbd>
                            <span>Navigate between items</span>
                        </div>
                        <div class="shortcut-item">
                            <kbd>Shift</kbd> + <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> or <kbd>Shift</kbd> + <kbd>J</kbd> <kbd>K</kbd>
                            <span>Navigate to unrated items</span>
                        </div>
                        <div class="shortcut-item">
                            <kbd>Space</kbd>
                            <span>Skip to next item</span>
                        </div>
                    </div>
                </div>

                <div class="help-section">
                    <h3>üìù Display & Export</h3>
                    <div class="shortcut-list">
                        <div class="shortcut-item">
                            <kbd>‚åò</kbd> + <kbd>M</kbd> <small>(or Ctrl+M)</small>
                            <span>Toggle markdown rendering mode</span>
                        </div>
                        <div class="shortcut-item">
                            <kbd>‚åò</kbd> + <kbd>E</kbd> <small>(or Ctrl+E)</small>
                            <span>Export results</span>
                        </div>
                        <div class="shortcut-item">
                            <kbd>M</kbd>
                            <span>Add/edit comment</span>
                        </div>
                        <div class="shortcut-item">
                            <kbd>Shift</kbd> + <kbd>Enter</kbd>
                            <span>Save comment (in comment modal)</span>
                        </div>
                        <div class="shortcut-item">
                            <kbd>?</kbd>
                            <span>Show/hide this help screen</span>
                        </div>
                        <div class="shortcut-item">
                            <kbd>Esc</kbd>
                            <span>Close help screen</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Comment Modal -->
    <div id="comment-modal" class="comment-modal hidden">
        <div class="comment-overlay" id="comment-overlay"></div>
        <div class="comment-content">
            <div class="comment-header">
                <h2>üí¨ Add Comment</h2>
                <button id="comment-close" class="comment-close">√ó</button>
            </div>
            <div class="comment-body">
                <textarea id="comment-text" class="comment-textarea" placeholder="Add your comment here..." rows="4"></textarea>
                <div class="comment-actions">
                    <button id="comment-save" class="comment-save-btn">Save</button>
                    <button id="comment-delete" class="comment-delete-btn">Delete</button>
                    <button id="comment-cancel" class="comment-cancel-btn">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script src="/app.js"></script>
</body>
</html>`,
  'styles.css': `* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: white;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
    overflow: hidden;
}

.header {
    padding: 0.75rem 1rem;
    background: #2563eb;
    color: white;
    border-bottom: 2px solid #1d4ed8;
    flex-shrink: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.title {
    font-size: 1.1rem;
    font-weight: 600;
}

.mode-indicator {
    display: flex;
    gap: 0.5rem;
}

.mode-badge {
    background: rgba(255, 255, 255, 0.2);
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.875rem;
    font-weight: 500;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.mode-badge.hidden {
    display: none;
}

.content {
    flex: 1;
    padding: 0.5rem;
    display: flex;
    align-items: stretch;
    justify-content: center;
    overflow: hidden;
    min-height: 0;
}

.content-display {
    width: 100%;
    max-width: none;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 14px;
    line-height: 1.5;
    background: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 4px;
    padding: 1rem;
    height: 100%;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.file-content .line {
    margin: 2px 0;
    white-space: pre-wrap;
}

.line-number {
    color: #6b7280;
    margin-right: 1rem;
    user-select: none;
    display: inline-block;
    width: 3em;
    text-align: right;
}

.csv-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 15px;
    margin: 0;
}

.csv-table th,
.csv-table td {
    padding: 12px 16px;
    text-align: left;
    border-bottom: 1px solid #e5e7eb;
    vertical-align: top;
    word-wrap: break-word;
}

.csv-table th {
    background: #f3f4f6;
    font-weight: 600;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #374151;
    position: sticky;
    top: 0;
    z-index: 1;
}

.csv-table td {
    line-height: 1.6;
    min-height: 60px;
}

.csv-table tr:hover {
    background-color: #f9fafb;
}

.status {
    padding: 0.5rem 1rem;
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
    border-bottom: 1px solid #e9ecef;
    flex-shrink: 0;
}

.status-indicator {
    font-weight: 600;
    font-size: 0.9rem;
}

.status-text {
    padding: 0.25rem 0.75rem;
    border-radius: 20px;
    font-size: 0.875rem;
}

.controls {
    padding: 0.75rem 1rem;
    flex-shrink: 0;
}

.category-buttons {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    justify-content: center;
}

.category-btn {
    padding: 0.5rem 1rem;
    border: 1px solid #d1d5db;
    background: white;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.8rem;
    transition: all 0.2s;
    min-width: 80px;
}

.category-btn:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
}

.category-btn:active {
    transform: translateY(1px);
}

.category-btn.selected {
    background: #2563eb;
    border-color: #2563eb;
    color: white;
}

.navigation {
    padding: 0.5rem 1rem;
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}

.nav-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.nav-btn {
    padding: 0.4rem 0.8rem;
    border: 1px solid #d1d5db;
    background: white;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    font-size: 0.85rem;
    transition: all 0.2s;
}

.nav-btn:hover:not(:disabled) {
    background: #f3f4f6;
    border-color: #9ca3af;
}

.nav-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.nav-progress {
    font-weight: 600;
    font-size: 1rem;
    min-width: 4rem;
    text-align: center;
}

.stats {
    display: flex;
    gap: 1rem;
}

.stat {
    padding: 0.25rem 0.5rem;
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 4px;
    font-size: 0.875rem;
    font-weight: 500;
}

.loading {
    text-align: center;
    color: #6b7280;
    font-style: italic;
}

/* Markdown Content Styles */
.markdown-content {
    padding: 1rem;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
    line-height: 1.6;
    color: #374151;
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
    margin: 1.5rem 0 0.5rem 0;
    font-weight: 600;
    color: #1f2937;
}

.markdown-content h1 { font-size: 2rem; }
.markdown-content h2 { font-size: 1.5rem; }
.markdown-content h3 { font-size: 1.25rem; }

.markdown-content p {
    margin: 0.75rem 0;
}

.markdown-content ul,
.markdown-content ol {
    margin: 0.75rem 0;
    padding-left: 2rem;
}

.markdown-content li {
    margin: 0.25rem 0;
}

.markdown-content blockquote {
    border-left: 4px solid #e5e7eb;
    margin: 1rem 0;
    padding-left: 1rem;
    color: #6b7280;
    font-style: italic;
}

.markdown-content code {
    background: #f3f4f6;
    padding: 0.125rem 0.25rem;
    border-radius: 3px;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    font-size: 0.875em;
}

.markdown-content pre {
    background: #f3f4f6;
    padding: 1rem;
    border-radius: 6px;
    overflow-x: auto;
    margin: 1rem 0;
}

.markdown-content pre code {
    background: none;
    padding: 0;
}

.markdown-content a {
    color: #2563eb;
    text-decoration: underline;
}

.markdown-content a:hover {
    color: #1d4ed8;
}

.markdown-content strong {
    font-weight: 600;
}

.markdown-content em {
    font-style: italic;
}

.markdown-content table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
}

.markdown-content th,
.markdown-content td {
    border: 1px solid #e5e7eb;
    padding: 0.5rem;
    text-align: left;
}

.markdown-content th {
    background: #f9fafb;
    font-weight: 600;
}

.markdown-cell {
    padding: 0.5rem !important;
}

.markdown-cell p:first-child {
    margin-top: 0;
}

.markdown-cell p:last-child {
    margin-bottom: 0;
}

.markdown-cell strong {
    font-weight: 800;
    color: #000000;
    text-shadow: 0 0 1px rgba(0,0,0,0.3);
}

.markdown-cell em {
    font-style: italic;
    color: #1565c0;
    font-weight: 500;
}

.markdown-cell code {
    background: #f3f4f6;
    padding: 0.125rem 0.25rem;
    border-radius: 3px;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    font-size: 0.875em;
}

/* Help Modal Styles */
.help-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.2s ease-in-out;
}

.help-modal.hidden {
    display: none;
}

.help-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(2px);
}

.help-content {
    position: relative;
    background: white;
    border-radius: 12px;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow: hidden;
    animation: slideIn 0.2s ease-out;
}

.help-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.5rem;
    background: #2563eb;
    color: white;
}

.help-header h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 600;
}

.help-close {
    background: none;
    border: none;
    color: white;
    font-size: 2rem;
    cursor: pointer;
    padding: 0;
    width: 2rem;
    height: 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.help-close:hover {
    background: rgba(255, 255, 255, 0.1);
}

.help-body {
    padding: 1.5rem;
    max-height: 60vh;
    overflow-y: auto;
}

.help-section {
    margin-bottom: 2rem;
}

.help-section:last-child {
    margin-bottom: 0;
}

.help-section h3 {
    margin: 0 0 1rem 0;
    font-size: 1.125rem;
    font-weight: 600;
    color: #374151;
}

.shortcut-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.shortcut-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.5rem;
    border-radius: 6px;
    background: #f9fafb;
    border: 1px solid #e5e7eb;
}

.shortcut-item kbd {
    background: #374151;
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.875rem;
    font-weight: 600;
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    min-width: 2rem;
    text-align: center;
    display: inline-block;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.shortcut-item small {
    color: #6b7280;
    font-size: 0.75rem;
    margin-left: 0.25rem;
}

.shortcut-item span {
    flex: 1;
    color: #374151;
    font-size: 0.9rem;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: scale(0.95) translateY(-20px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

@media (max-width: 768px) {
    .container {
        margin: 0;
        min-height: 100vh;
    }

    .header, .content, .status, .controls, .navigation {
        padding-left: 1rem;
        padding-right: 1rem;
    }

    .category-buttons {
        justify-content: stretch;
    }

    .category-btn {
        flex: 1;
        min-width: auto;
    }

    .navigation {
        flex-direction: column;
        gap: 1rem;
    }
}

/* Comment Styles */
.comment-btn {
    /* Inherits nav-btn styles - no additional styling needed */
}

.comment-display {
    background: #f8fafc;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    padding: 0.5rem;
    margin-top: 0.5rem;
}

.comment-preview {
    font-size: 0.8rem;
    color: #475569;
    line-height: 1.4;
}

.comment-preview strong {
    color: #334155;
    font-weight: 600;
}

/* Comment Modal Styles */
.comment-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.2s ease-in-out;
}

.comment-modal.hidden {
    display: none;
}

.comment-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(2px);
}

.comment-content {
    position: relative;
    background: white;
    border-radius: 12px;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow: hidden;
    animation: slideIn 0.2s ease-out;
}

.comment-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.5rem;
    background: #2563eb;
    color: white;
}

.comment-header h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 600;
}

.comment-close {
    background: none;
    border: none;
    color: white;
    font-size: 2rem;
    cursor: pointer;
    padding: 0;
    width: 2rem;
    height: 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: background-color 0.2s;
}

.comment-close:hover {
    background: rgba(255, 255, 255, 0.1);
}

.comment-body {
    padding: 1.5rem;
}

.comment-textarea {
    width: 100%;
    min-height: 120px;
    padding: 0.75rem;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-family: inherit;
    font-size: 0.875rem;
    line-height: 1.5;
    resize: vertical;
    background: white;
    transition: border-color 0.2s;
}

.comment-textarea:focus {
    outline: none;
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.comment-actions {
    display: flex;
    gap: 0.75rem;
    margin-top: 1rem;
    justify-content: flex-end;
}

.comment-save-btn,
.comment-delete-btn,
.comment-cancel-btn {
    padding: 0.5rem 1rem;
    border: 1px solid;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    font-size: 0.875rem;
    transition: all 0.2s;
}

.comment-save-btn {
    background: #2563eb;
    border-color: #2563eb;
    color: white;
}

.comment-save-btn:hover {
    background: #1d4ed8;
    border-color: #1d4ed8;
}

.comment-delete-btn {
    background: #dc2626;
    border-color: #dc2626;
    color: white;
}

.comment-delete-btn:hover {
    background: #b91c1c;
    border-color: #b91c1c;
}

.comment-cancel-btn {
    background: white;
    border-color: #d1d5db;
    color: #374151;
}

.comment-cancel-btn:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
}`,
  'app.js': `class ClassifierApp {
    constructor() {
        this.state = null;
        this.currentItem = null;
        this.currentIndex = 0;
        this.isClassifying = false; // Prevent rapid classifications
        this.hasInitialized = false; // Track initial load
        this.markdownMode = false; // Track markdown rendering mode
        this.debounceTimeouts = new Map(); // For debouncing rapid actions

        this.elements = {
            filename: document.getElementById('filename'),
            progress: document.getElementById('progress'),
            contentDisplay: document.getElementById('content-display'),
            classificationStatus: document.getElementById('classification-status'),
            categoryButtons: document.getElementById('category-buttons'),
            prevBtn: document.getElementById('prev-btn'),
            nextBtn: document.getElementById('next-btn'),
            navProgress: document.getElementById('nav-progress'),
            statsClassified: document.getElementById('stats-classified'),
            statsSkipped: document.getElementById('stats-skipped'),
            statsRemaining: document.getElementById('stats-remaining'),
            helpModal: document.getElementById('help-modal'),
            helpClose: document.getElementById('help-close'),
            helpOverlay: document.getElementById('help-overlay'),
            markdownIndicator: document.getElementById('markdown-indicator'),
            commentBtn: document.getElementById('comment-btn'),
            commentDisplay: document.getElementById('comment-display'),
            commentModal: document.getElementById('comment-modal'),
            commentClose: document.getElementById('comment-close'),
            commentOverlay: document.getElementById('comment-overlay'),
            commentText: document.getElementById('comment-text'),
            commentSave: document.getElementById('comment-save'),
            commentDelete: document.getElementById('comment-delete'),
            commentCancel: document.getElementById('comment-cancel'),
        };

        // Configure marked for GitHub-flavored markdown
        marked.setOptions({
            gfm: true,
            breaks: true,
            sanitize: false,
            smartLists: true,
            smartypants: false,
            xhtml: false
        });

        this.init();
    }

    async init() {
        try {
            // Show initial loading state
            this.showLoading('Initializing application...');

            await this.loadState();
            this.setupEventListeners();
            await this.loadCurrentItem();
            this.updateDisplay();

            // Hide loading state
            this.hideLoading();
        } catch (error) {
            console.error('Failed to initialize app:', error);
            this.hideLoading();
            this.showError('Failed to load application: ' + error.message);
        }
    }

    async loadState() {
        const response = await fetch('/api/state');
        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error || 'Failed to load state');
        }

        this.state = result.data;

        // Only set currentIndex on initial load, not after classification
        if (!this.hasInitialized) {
            this.currentIndex = this.state.currentIndex || 0;
            this.hasInitialized = true;
        }
    }

    setupEventListeners() {
        // Navigation buttons
        this.elements.prevBtn.addEventListener('click', () => this.navigatePrev());
        this.elements.nextBtn.addEventListener('click', () => this.navigateNext());

        // Unified keyboard handler
        document.addEventListener('keydown', (event) => this.handleKeyboard(event));

        // Help modal event listeners
        this.elements.helpClose.addEventListener('click', () => this.hideHelp());
        this.elements.helpOverlay.addEventListener('click', () => this.hideHelp());

        // Comment modal event listeners
        this.elements.commentBtn.addEventListener('click', () => this.showCommentModal());
        this.elements.commentClose.addEventListener('click', () => this.hideCommentModal());
        this.elements.commentOverlay.addEventListener('click', () => this.hideCommentModal());
        this.elements.commentSave.addEventListener('click', () => this.saveComment());
        this.elements.commentDelete.addEventListener('click', () => this.deleteComment());
        this.elements.commentCancel.addEventListener('click', () => this.hideCommentModal());

        // Comment textarea keyboard shortcut (Shift+Enter to save)
        this.elements.commentText.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && event.shiftKey) {
                event.preventDefault();
                this.saveComment();
            }
        });
    }

    handleKeyboard(event) {
        const key = event.key;

        if (key === 'Escape') {
            event.preventDefault();
            // Close whichever modal is open
            if (!this.elements.helpModal.classList.contains('hidden')) {
                this.hideHelp();
            } else if (!this.elements.commentModal.classList.contains('hidden')) {
                this.hideCommentModal();
            }
            return;
        }

        // Don't handle other shortcuts if any modal is open
        if (!this.elements.helpModal.classList.contains('hidden') ||
            !this.elements.commentModal.classList.contains('hidden')) {
            return;
        }

        // Help modal shortcuts (only when no modal is open)
        if (key === '?' || key === '/') {
            event.preventDefault();
            this.toggleHelp();
            return;
        }

        // Export functionality
        if (key === 'e' && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            this.exportResults();
            return;
        }

        // Markdown mode toggle
        if (key === 'm' && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            this.toggleMarkdownMode();
            return;
        }

        // Comment modal shortcut (only if no modifier keys are pressed)
        if ((key === 'm' || key === 'M') && !event.metaKey && !event.ctrlKey && !event.altKey && !event.shiftKey) {
            event.preventDefault();
            this.showCommentModal();
            return;
        }

        // Category shortcuts (1-9)
        if (key >= '1' && key <= '9') {
            const categoryIndex = parseInt(key);
            if (categoryIndex <= this.state.config.categories.length) {
                event.preventDefault();
                this.classifyCurrentItem(categoryIndex);
            }
            return;
        }

        // Navigation shortcuts
        switch (key) {
            case 'ArrowLeft':
            case 'h':
                if (event.shiftKey) {
                    event.preventDefault();
                    this.navigateToPrevUnrated();
                } else {
                    event.preventDefault();
                    this.navigatePrev();
                }
                break;
            case 'ArrowRight':
            case 'l':
                if (event.shiftKey) {
                    event.preventDefault();
                    this.navigateToNextUnrated();
                } else {
                    event.preventDefault();
                    this.navigateNext();
                }
                break;
            case 'j':
                if (event.shiftKey) {
                    event.preventDefault();
                    this.navigateToNextUnrated();
                } else {
                    event.preventDefault();
                    this.navigateNext();
                }
                break;
            case 'k':
                if (event.shiftKey) {
                    event.preventDefault();
                    this.navigateToPrevUnrated();
                } else {
                    event.preventDefault();
                    this.navigatePrev();
                }
                break;
            case ' ': // Spacebar to skip
                event.preventDefault();
                this.navigateNext();
                break;
        }
    }

    async loadCurrentItem() {
        if (this.currentIndex < 0 || this.currentIndex >= this.state.totalItems) {
            this.currentItem = null;
            return;
        }

        try {
            const response = await fetch(\`/api/item?index=\${this.currentIndex}\`);
            const result = await response.json();

            if (result.success) {
                this.currentItem = result.data;
            } else {
                throw new Error(result.error || 'Failed to load item');
            }
        } catch (error) {
            console.error('Failed to load current item:', error);
            this.showError('Failed to load content');
        }
    }

    updateDisplay() {
        this.updateHeader();
        this.updateContent();
        this.updateCategoryButtons();
        this.updateClassificationStatus();
        this.updateCommentDisplay();
        this.updateNavigation();
        this.updateStats();
    }

    updateHeader() {
        if (this.currentItem) {
            const filename = this.currentItem.filename || 'Unknown';
            const mode = this.state.config.mode === 'csv' ? 'CSV' : 'File';
            this.elements.filename.textContent = \`\${filename} (\${mode})\`;
        } else {
            this.elements.filename.textContent = 'No content';
        }

        this.elements.progress.textContent = \`\${this.currentIndex + 1}/\${this.state.totalItems}\`;
    }

    updateContent() {
        if (!this.currentItem) {
            this.elements.contentDisplay.innerHTML = '<div class="loading">No content available</div>';
            return;
        }

        if (this.state.config.mode === 'csv') {
            this.renderCSVContent();
        } else {
            this.renderFileContent();
        }
    }

    renderFileContent() {
        if (this.markdownMode) {
            // Render as markdown
            const markdownHtml = marked.parse(this.currentItem.content);
            this.elements.contentDisplay.innerHTML = \`<div class="markdown-content">\${markdownHtml}</div>\`;
        } else {
            // Render as plain text with line numbers
            const lines = this.currentItem.content.split('\\n');
            const html = lines
                .map((line, index) => {
                    const lineNum = index + 1;
                    const escapedLine = this.escapeHtml(line);
                    return \`<div class="line"><span class="line-number">\${lineNum}</span>\${escapedLine}</div>\`;
                })
                .join('');

            this.elements.contentDisplay.innerHTML = \`<div class="file-content">\${html}</div>\`;
        }
    }

    renderCSVContent() {
        if (!this.currentItem.csvRow) {
            this.elements.contentDisplay.innerHTML = '<div class="loading">Invalid CSV data</div>';
            return;
        }

        const rows = Object.entries(this.currentItem.csvRow)
            .map(([key, value]) => {
                const escapedKey = this.escapeHtml(key);
                let cellContent;

                if (this.markdownMode) {
                    // Render value as inline markdown (no wrapping <p> tags for table cells)
                    cellContent = marked.parseInline(value || '');
                } else {
                    // Render as plain text with newline expansion
                    cellContent = this.escapeHtmlWithNewlines(value);
                }

                return \`<tr><th>\${escapedKey}</th><td class="\${this.markdownMode ? 'markdown-cell' : ''}">\${cellContent}</td></tr>\`;
            })
            .join('');

        this.elements.contentDisplay.innerHTML = \`
            <table class="csv-table">
                <tbody>\${rows}</tbody>
            </table>
        \`;
    }

    updateCategoryButtons() {
        const categories = this.state.config.categories;
        const currentClassification = this.getCurrentClassification();

        let html = '';
        categories.forEach((category, index) => {
            const categoryNum = index + 1;
            const isSelected = currentClassification && currentClassification.category === categoryNum;
            const selectedClass = isSelected ? ' selected' : '';

            html += \`
                <button class="category-btn\${selectedClass}" data-category="\${categoryNum}">
                    [\${categoryNum}] \${this.escapeHtml(category)}
                </button>
            \`;
        });

        this.elements.categoryButtons.innerHTML = html;

        // Add event listeners to category buttons
        this.elements.categoryButtons.querySelectorAll('.category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const category = parseInt(btn.dataset.category);
                this.classifyCurrentItem(category);
            });
        });
    }

    updateClassificationStatus() {
        const classification = this.getCurrentClassification();

        if (classification) {
            const categoryName = classification.categoryName;
            this.elements.classificationStatus.innerHTML = \`
                <span style="color: #059669;">‚úÖ \${this.escapeHtml(categoryName)}</span>
            \`;
        } else {
            this.elements.classificationStatus.innerHTML = \`
                <span style="color: #6b7280;">‚ö™ Unclassified</span>
            \`;
        }
    }

    updateNavigation() {
        // Update button states
        this.elements.prevBtn.disabled = this.currentIndex <= 0;
        this.elements.nextBtn.disabled = this.currentIndex >= this.state.totalItems - 1;

        // Update progress
        this.elements.navProgress.textContent = \`\${this.currentIndex + 1}/\${this.state.totalItems}\`;
    }

    updateStats() {
        const classifiedCount = this.state.classifications.length;
        const skippedCount = 0; // We don't track skips separately for now
        const remainingCount = this.state.totalItems - classifiedCount;

        this.elements.statsClassified.textContent = \`‚úÖ\${classifiedCount}\`;
        this.elements.statsSkipped.textContent = \`‚è≠\${skippedCount}\`;
        this.elements.statsRemaining.textContent = \`‚è≥\${remainingCount}\`;
    }

    async classifyCurrentItem(category) {
        if (!this.currentItem || this.isClassifying) {
            return;
        }

        this.isClassifying = true;

        // Show visual feedback during classification
        this.elements.classificationStatus.innerHTML = \`
            <span style="color: #6b7280;">‚è≥ Classifying...</span>
        \`;

        try {
            const response = await fetch('/api/classify', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    itemIndex: this.currentIndex,
                    category: category,
                }),
            });

            const result = await response.json();

            if (result.success) {
                // Update local state
                await this.loadState();
                this.updateDisplay();

                // Auto-navigate to next item (only if not on last item)
                if (this.currentIndex < this.state.totalItems - 1) {
                    // Use requestAnimationFrame for reliable timing after DOM updates
                    requestAnimationFrame(() => {
                        this.navigateNext();
                    });
                }
            } else {
                throw new Error(result.error || 'Classification failed');
            }
        } catch (error) {
            console.error('Classification error:', error);
            this.showError('Failed to classify item');
        } finally {
            this.isClassifying = false;
        }
    }

    async navigatePrev() {
        this.debounce('navigate', async () => {
            if (this.currentIndex > 0) {
                this.currentIndex--;
                await this.loadCurrentItem();
                this.updateDisplay();
            }
        });
    }

    async navigateNext() {
        this.debounce('navigate', async () => {
            if (this.currentIndex < this.state.totalItems - 1) {
                this.currentIndex++;
                await this.loadCurrentItem();
                this.updateDisplay();
            }
        });
    }

    async navigateToNextUnrated() {
        const startIndex = this.currentIndex + 1;
        let foundIndex = -1;

        // Search forward for next unrated item
        for (let i = startIndex; i < this.state.totalItems; i++) {
            const response = await fetch(\`/api/item?index=\${i}\`);
            const result = await response.json();
            if (result.success) {
                const item = result.data;
                const isClassified = this.state.classifications.find(c => c.itemId === item.id);
                if (!isClassified) {
                    foundIndex = i;
                    break;
                }
            }
        }

        if (foundIndex !== -1) {
            this.currentIndex = foundIndex;
            await this.loadCurrentItem();
            this.updateDisplay();
        }
        // If no unrated items found, do nothing (stay at current position)
    }

    async navigateToPrevUnrated() {
        const startIndex = this.currentIndex - 1;
        let foundIndex = -1;

        // Search backward for previous unrated item
        for (let i = startIndex; i >= 0; i--) {
            const response = await fetch(\`/api/item?index=\${i}\`);
            const result = await response.json();
            if (result.success) {
                const item = result.data;
                const isClassified = this.state.classifications.find(c => c.itemId === item.id);
                if (!isClassified) {
                    foundIndex = i;
                    break;
                }
            }
        }

        if (foundIndex !== -1) {
            this.currentIndex = foundIndex;
            await this.loadCurrentItem();
            this.updateDisplay();
        }
        // If no unrated items found, do nothing (stay at current position)
    }

    getCurrentClassification() {
        if (!this.currentItem) {
            return null;
        }

        return this.state.classifications.find(c => c.itemId === this.currentItem.id);
    }

    async exportResults() {
        try {
            const response = await fetch('/api/export', {
                method: 'POST',
            });

            const result = await response.json();

            if (result.success) {
                this.downloadJSON(result.data, \`classifications-\${Date.now()}.json\`);
            } else {
                throw new Error(result.error || 'Export failed');
            }
        } catch (error) {
            console.error('Export error:', error);
            this.showError('Failed to export results');
        }
    }

    downloadJSON(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    showError(message) {
        // Simple error display - could be enhanced with a proper toast system
        console.error(message);
        alert(message);
    }

    showLoading(message = 'Loading...') {
        if (this.elements.contentDisplay) {
            this.elements.contentDisplay.innerHTML = \`<div class="loading">\${this.escapeHtml(message)}</div>\`;
        }
    }

    hideLoading() {
        // Loading will be replaced by content when updateDisplay is called
    }

    /**
     * Debounce function calls to prevent rapid execution
     * @param {string} key - Unique key for the debounced function
     * @param {Function} func - Function to debounce
     * @param {number} wait - Wait time in milliseconds
     */
    debounce(key, func, wait = 150) {
        // Clear existing timeout
        if (this.debounceTimeouts.has(key)) {
            clearTimeout(this.debounceTimeouts.get(key));
        }

        // Set new timeout
        const timeoutId = setTimeout(() => {
            this.debounceTimeouts.delete(key);
            func();
        }, wait);

        this.debounceTimeouts.set(key, timeoutId);
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    escapeHtmlWithNewlines(text) {
        // First escape HTML, then convert newlines to <br> tags
        const escaped = this.escapeHtml(text);
        return escaped.replace(/\\n/g, '<br>');
    }

    // Help modal methods
    showHelp() {
        this.elements.helpModal.classList.remove('hidden');
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }

    hideHelp() {
        this.elements.helpModal.classList.add('hidden');
        document.body.style.overflow = ''; // Restore scrolling
    }

    toggleHelp() {
        if (this.elements.helpModal.classList.contains('hidden')) {
            this.showHelp();
        } else {
            this.hideHelp();
        }
    }

    // Markdown mode methods
    toggleMarkdownMode() {
        this.markdownMode = !this.markdownMode;
        this.updateMarkdownIndicator();
        this.updateContent(); // Re-render content with new mode
    }

    updateMarkdownIndicator() {
        if (this.markdownMode) {
            this.elements.markdownIndicator.classList.remove('hidden');
        } else {
            this.elements.markdownIndicator.classList.add('hidden');
        }
    }

    // Comment methods
    updateCommentDisplay() {
        const classification = this.getCurrentClassification();
        const comment = classification?.comment;

        if (comment && comment.trim()) {
            this.elements.commentDisplay.innerHTML = \`
                <div class="comment-preview">
                    <strong>üí¨ Comment:</strong> \${this.escapeHtml(comment)}
                </div>
            \`;
            this.elements.commentDisplay.classList.remove('hidden');
        } else {
            this.elements.commentDisplay.innerHTML = '';
            this.elements.commentDisplay.classList.add('hidden');
        }
    }

    showCommentModal() {
        const classification = this.getCurrentClassification();
        const existingComment = classification?.comment || '';

        this.elements.commentText.value = existingComment;
        this.elements.commentModal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';

        // Focus the textarea
        setTimeout(() => {
            this.elements.commentText.focus();
        }, 100);

        // Update delete button visibility
        this.elements.commentDelete.style.display = existingComment ? 'block' : 'none';
    }

    hideCommentModal() {
        this.elements.commentModal.classList.add('hidden');
        document.body.style.overflow = '';
    }

    async saveComment() {
        const comment = this.elements.commentText.value.trim();

        if (!comment) {
            this.showError('Comment cannot be empty. Use Delete to remove an existing comment.');
            return;
        }

        try {
            const response = await fetch('/api/comment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    itemIndex: this.currentIndex,
                    comment: comment,
                }),
            });

            const result = await response.json();

            if (result.success) {
                // Reload state to get updated classification with comment
                await this.loadState();
                await this.loadCurrentItem();
                this.updateDisplay();
                this.hideCommentModal();
            } else {
                throw new Error(result.error || 'Failed to save comment');
            }
        } catch (error) {
            console.error('Save comment error:', error);
            this.showError('Failed to save comment');
        }
    }

    async deleteComment() {
        try {
            const response = await fetch(\`/api/comment?index=\${this.currentIndex}\`, {
                method: 'DELETE',
            });

            const result = await response.json();

            if (result.success) {
                // Reload state to get updated classification without comment
                await this.loadState();
                await this.loadCurrentItem();
                this.updateDisplay();
                this.hideCommentModal();
            } else {
                throw new Error(result.error || 'Failed to delete comment');
            }
        } catch (error) {
            console.error('Delete comment error:', error);
            this.showError('Failed to delete comment');
        }
    }
}

// Initialize the app when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new ClassifierApp();
});`,
  'components/CommentModal.js': `/**
 * CommentModal - Handles comment functionality for classification items
 */
export class CommentModal {
    constructor(apiService, stateManager) {
        this.apiService = apiService;
        this.stateManager = stateManager;

        this.elements = {
            modal: document.getElementById('comment-modal'),
            close: document.getElementById('comment-close'),
            overlay: document.getElementById('comment-overlay'),
            text: document.getElementById('comment-text'),
            save: document.getElementById('comment-save'),
            delete: document.getElementById('comment-delete'),
            cancel: document.getElementById('comment-cancel'),
            display: document.getElementById('comment-display'),
            btn: document.getElementById('comment-btn'),
        };

        this.setupEventListeners();
    }

    setupEventListeners() {
        // Modal event listeners
        this.elements.btn.addEventListener('click', () => this.show());
        this.elements.close.addEventListener('click', () => this.hide());
        this.elements.overlay.addEventListener('click', () => this.hide());
        this.elements.save.addEventListener('click', () => this.save());
        this.elements.delete.addEventListener('click', () => this.delete());
        this.elements.cancel.addEventListener('click', () => this.hide());

        // Comment textarea keyboard shortcut (Shift+Enter to save)
        this.elements.text.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && event.shiftKey) {
                event.preventDefault();
                this.save();
            }
        });
    }

    show() {
        const currentState = this.stateManager.getState();
        const classification = this.getCurrentClassification(currentState);
        const existingComment = classification?.comment || '';

        this.elements.text.value = existingComment;
        this.elements.modal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';

        // Focus the textarea
        setTimeout(() => {
            this.elements.text.focus();
        }, 100);

        // Update delete button visibility
        this.elements.delete.style.display = existingComment ? 'block' : 'none';
    }

    hide() {
        this.elements.modal.classList.add('hidden');
        document.body.style.overflow = '';
    }

    async save() {
        const comment = this.elements.text.value.trim();

        if (!comment) {
            this.showError('Comment cannot be empty. Use Delete to remove an existing comment.');
            return;
        }

        try {
            const currentState = this.stateManager.getState();
            const response = await this.apiService.saveComment(currentState.currentIndex, comment);

            if (response.success) {
                // Update state and refresh display
                await this.stateManager.refreshState();
                this.hide();
                this.updateDisplay();
            } else {
                throw new Error(response.error || 'Failed to save comment');
            }
        } catch (error) {
            console.error('Save comment error:', error);
            this.showError('Failed to save comment');
        }
    }

    async delete() {
        try {
            const currentState = this.stateManager.getState();
            const response = await this.apiService.deleteComment(currentState.currentIndex);

            if (response.success) {
                // Update state and refresh display
                await this.stateManager.refreshState();
                this.hide();
                this.updateDisplay();
            } else {
                throw new Error(response.error || 'Failed to delete comment');
            }
        } catch (error) {
            console.error('Delete comment error:', error);
            this.showError('Failed to delete comment');
        }
    }

    updateDisplay() {
        const currentState = this.stateManager.getState();
        const classification = this.getCurrentClassification(currentState);
        const comment = classification?.comment;

        if (comment && comment.trim()) {
            this.elements.display.innerHTML = \`
                <div class="comment-preview">
                    <strong>üí¨ Comment:</strong> \${this.escapeHtml(comment)}
                </div>
            \`;
            this.elements.display.classList.remove('hidden');
        } else {
            this.elements.display.classList.add('hidden');
        }
    }

    getCurrentClassification(state) {
        const currentItem = state.items?.[state.currentIndex];
        if (!currentItem) return null;
        return state.classifications?.find(c => c.itemId === currentItem.id);
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    showError(message) {
        // For now, use alert. This could be replaced with a proper error notification system
        alert(message);
    }

    isVisible() {
        return !this.elements.modal.classList.contains('hidden');
    }
}`,
  'services/ApiService.js': `/**
 * ApiService - Centralized API communication
 */
export class ApiService {
    constructor() {
        this.baseUrl = '';
    }

    async loadState() {
        const response = await fetch('/api/state');
        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error || 'Failed to load state');
        }

        return result.data;
    }

    async loadItem(index) {
        const response = await fetch(\`/api/item/\${index}\`);
        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error || 'Failed to load item');
        }

        return result.data;
    }

    async classify(itemIndex, category) {
        const response = await fetch('/api/classify', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                itemIndex,
                category,
            }),
        });

        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error || 'Failed to classify item');
        }

        return result;
    }

    async saveComment(itemIndex, comment) {
        const response = await fetch('/api/comment', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                itemIndex,
                comment,
            }),
        });

        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error || 'Failed to save comment');
        }

        return result;
    }

    async deleteComment(itemIndex) {
        const response = await fetch(\`/api/comment?index=\${itemIndex}\`, {
            method: 'DELETE',
        });

        const result = await response.json();

        if (!result.success) {
            throw new Error(result.error || 'Failed to delete comment');
        }

        return result;
    }

    async exportResults() {
        const response = await fetch('/api/export', {
            method: 'POST',
        });

        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'classifications.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } else {
            throw new Error('Failed to export results');
        }
    }
}`,
  'services/KeyboardService.js': `/**
 * KeyboardService - Unified keyboard handling for the application
 */
export class KeyboardService {
    constructor() {
        this.handlers = new Map();
        this.modalHandlers = new Map();
        this.isModalOpen = false;

        // Bind the main keyboard handler
        document.addEventListener('keydown', this.handleKeydown.bind(this));
    }

    /**
     * Register a keyboard shortcut
     * @param {string} key - The key to listen for
     * @param {Object} options - Options object
     * @param {Function} handler - Function to call when key is pressed
     * @param {string} context - 'global' or 'modal'
     */
    register(key, options = {}, handler, context = 'global') {
        const {
            ctrlKey = false,
            metaKey = false,
            shiftKey = false,
            altKey = false,
            preventDefault = true
        } = options;

        const keyCombo = this.getKeyCombo(key, { ctrlKey, metaKey, shiftKey, altKey });
        const handlerInfo = { handler, preventDefault };

        if (context === 'modal') {
            this.modalHandlers.set(keyCombo, handlerInfo);
        } else {
            this.handlers.set(keyCombo, handlerInfo);
        }
    }

    /**
     * Unregister a keyboard shortcut
     * @param {string} key - The key
     * @param {Object} options - Options object
     * @param {string} context - 'global' or 'modal'
     */
    unregister(key, options = {}, context = 'global') {
        const keyCombo = this.getKeyCombo(key, options);

        if (context === 'modal') {
            this.modalHandlers.delete(keyCombo);
        } else {
            this.handlers.delete(keyCombo);
        }
    }

    /**
     * Set modal state - affects which handlers are active
     * @param {boolean} isOpen - Whether a modal is currently open
     */
    setModalState(isOpen) {
        this.isModalOpen = isOpen;
    }

    /**
     * Main keyboard event handler
     * @param {KeyboardEvent} event - The keyboard event
     */
    handleKeydown(event) {
        // Handle Escape key specially - always closes modals
        if (event.key === 'Escape') {
            const escapeHandler = this.handlers.get('Escape');
            if (escapeHandler) {
                if (escapeHandler.preventDefault) {
                    event.preventDefault();
                }
                escapeHandler.handler(event);
            }
            return;
        }

        const keyCombo = this.getKeyCombo(event.key, {
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            shiftKey: event.shiftKey,
            altKey: event.altKey
        });

        // Check modal handlers first if modal is open
        if (this.isModalOpen) {
            const modalHandler = this.modalHandlers.get(keyCombo);
            if (modalHandler) {
                if (modalHandler.preventDefault) {
                    event.preventDefault();
                }
                modalHandler.handler(event);
                return;
            }
        }

        // Check global handlers
        const globalHandler = this.handlers.get(keyCombo);
        if (globalHandler) {
            if (globalHandler.preventDefault) {
                event.preventDefault();
            }
            globalHandler.handler(event);
        }
    }

    /**
     * Generate a unique key combination string
     * @param {string} key - The key
     * @param {Object} modifiers - Modifier keys
     * @returns {string} - Key combination string
     */
    getKeyCombo(key, modifiers = {}) {
        const { ctrlKey, metaKey, shiftKey, altKey } = modifiers;
        const parts = [];

        if (ctrlKey) parts.push('Ctrl');
        if (metaKey) parts.push('Meta');
        if (shiftKey) parts.push('Shift');
        if (altKey) parts.push('Alt');

        parts.push(key);

        return parts.join('+');
    }

    /**
     * Register common application shortcuts
     * @param {Object} handlers - Object with handler functions
     */
    registerApplicationShortcuts(handlers) {
        const {
            onClassify,
            onNavigateNext,
            onNavigatePrev,
            onExport,
            onToggleMarkdown,
            onShowComment,
            onShowHelp,
            onEscape,
            onNavigateUnrated
        } = handlers;

        // Category shortcuts (1-9)
        for (let i = 1; i <= 9; i++) {
            this.register(i.toString(), {}, (event) => {
                if (onClassify) onClassify(i, event);
            });
        }

        // Navigation shortcuts
        this.register('ArrowLeft', {}, onNavigatePrev);
        this.register('ArrowRight', {}, onNavigateNext);
        this.register('h', {}, onNavigatePrev);
        this.register('l', {}, onNavigateNext);

        // Unrated navigation shortcuts
        this.register('j', { shiftKey: true }, () => {
            if (onNavigateUnrated) onNavigateUnrated('next');
        });
        this.register('k', { shiftKey: true }, () => {
            if (onNavigateUnrated) onNavigateUnrated('prev');
        });

        // Export shortcut
        this.register('e', { ctrlKey: true }, onExport);
        this.register('e', { metaKey: true }, onExport);

        // Markdown toggle
        this.register('m', { ctrlKey: true }, onToggleMarkdown);
        this.register('m', { metaKey: true }, onToggleMarkdown);

        // Comment modal (only if no modifiers)
        this.register('m', {}, (event) => {
            // Only trigger if no modifier keys are pressed
            if (!event.metaKey && !event.ctrlKey && !event.altKey && !event.shiftKey) {
                if (onShowComment) onShowComment(event);
            }
        });

        // Help modal
        this.register('?', {}, onShowHelp);

        // Escape (close modals)
        this.register('Escape', {}, onEscape);
    }

    /**
     * Check if a key combination would conflict with existing handlers
     * @param {string} key - The key
     * @param {Object} modifiers - Modifier keys
     * @param {string} context - 'global' or 'modal'
     * @returns {boolean} - True if there's a conflict
     */
    hasConflict(key, modifiers = {}, context = 'global') {
        const keyCombo = this.getKeyCombo(key, modifiers);

        if (context === 'modal') {
            return this.modalHandlers.has(keyCombo);
        } else {
            return this.handlers.has(keyCombo);
        }
    }

    /**
     * Get all registered shortcuts for debugging
     * @returns {Object} - Object with global and modal handlers
     */
    getRegisteredShortcuts() {
        return {
            global: Array.from(this.handlers.keys()),
            modal: Array.from(this.modalHandlers.keys())
        };
    }
}`,
  'services/StateManager.js': `/**
 * StateManager - Centralized state management with observer pattern
 */
export class StateManager {
    constructor(apiService) {
        this.apiService = apiService;
        this.state = {
            currentIndex: 0,
            items: [],
            classifications: [],
            config: {
                categories: [],
                mode: 'file',
                sources: []
            },
            ui: {
                markdownMode: false,
                isLoading: false
            }
        };
        this.subscribers = [];
        this.hasInitialized = false;
    }

    /**
     * Subscribe to state changes
     * @param {Function} callback - Function to call when state changes
     * @returns {Function} - Unsubscribe function
     */
    subscribe(callback) {
        this.subscribers.push(callback);

        // Return unsubscribe function
        return () => {
            const index = this.subscribers.indexOf(callback);
            if (index > -1) {
                this.subscribers.splice(index, 1);
            }
        };
    }

    /**
     * Update state and notify subscribers
     * @param {Object} updates - Partial state updates
     */
    setState(updates) {
        const prevState = { ...this.state };
        this.state = this.mergeDeep(this.state, updates);

        // Notify all subscribers
        this.notify(prevState, this.state);
    }

    /**
     * Get current state (readonly)
     * @returns {Object} - Current state
     */
    getState() {
        return { ...this.state };
    }

    /**
     * Initialize state from API
     */
    async initialize() {
        try {
            this.setState({ ui: { ...this.state.ui, isLoading: true } });

            const serverState = await this.apiService.loadState();

            // Only set currentIndex on initial load
            const currentIndex = this.hasInitialized ? this.state.currentIndex : (serverState.currentIndex || 0);

            this.setState({
                ...serverState,
                currentIndex,
                ui: { ...this.state.ui, isLoading: false }
            });

            this.hasInitialized = true;
        } catch (error) {
            this.setState({ ui: { ...this.state.ui, isLoading: false } });
            throw error;
        }
    }

    /**
     * Refresh state from server without changing current index
     */
    async refreshState() {
        try {
            const serverState = await this.apiService.loadState();

            // Preserve current index and UI state
            this.setState({
                ...serverState,
                currentIndex: this.state.currentIndex,
                ui: this.state.ui
            });
        } catch (error) {
            console.error('Failed to refresh state:', error);
            throw error;
        }
    }

    /**
     * Navigate to specific index
     * @param {number} index - Target index
     */
    navigateToIndex(index) {
        const maxIndex = Math.max(0, this.state.items.length - 1);
        const newIndex = Math.max(0, Math.min(index, maxIndex));

        this.setState({ currentIndex: newIndex });
    }

    /**
     * Navigate to next item
     */
    navigateNext() {
        this.navigateToIndex(this.state.currentIndex + 1);
    }

    /**
     * Navigate to previous item
     */
    navigatePrev() {
        this.navigateToIndex(this.state.currentIndex - 1);
    }

    /**
     * Toggle markdown mode
     */
    toggleMarkdownMode() {
        this.setState({
            ui: {
                ...this.state.ui,
                markdownMode: !this.state.ui.markdownMode
            }
        });
    }

    /**
     * Get current item
     * @returns {Object|null} - Current item or null
     */
    getCurrentItem() {
        return this.state.items[this.state.currentIndex] || null;
    }

    /**
     * Get current classification
     * @returns {Object|null} - Current classification or null
     */
    getCurrentClassification() {
        const currentItem = this.state.items[this.state.currentIndex];
        if (!currentItem) return null;
        return this.state.classifications?.find(c => c.itemId === currentItem.id) || null;
    }

    /**
     * Get statistics
     * @returns {Object} - Statistics object
     */
    getStatistics() {
        const totalItems = this.state.items.length;
        const classifiedCount = this.state.classifications?.length || 0;
        const skippedCount = 0; // Not implemented yet
        const remainingCount = totalItems - classifiedCount - skippedCount;

        return {
            total: totalItems,
            classified: classifiedCount,
            skipped: skippedCount,
            remaining: remainingCount
        };
    }

    /**
     * Deep merge objects
     * @param {Object} target - Target object
     * @param {Object} source - Source object
     * @returns {Object} - Merged object
     */
    mergeDeep(target, source) {
        const result = { ...target };

        for (const key in source) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                result[key] = this.mergeDeep(target[key] || {}, source[key]);
            } else {
                result[key] = source[key];
            }
        }

        return result;
    }

    /**
     * Notify all subscribers of state changes
     * @param {Object} prevState - Previous state
     * @param {Object} newState - New state
     */
    notify(prevState, newState) {
        this.subscribers.forEach(callback => {
            try {
                callback(newState, prevState);
            } catch (error) {
                console.error('Error in state subscriber:', error);
            }
        });
    }
}`,
  'utils/constants.js': `/**
 * Application constants
 */

export const KEYBOARD_SHORTCUTS = {
    // Navigation
    PREV: ['ArrowLeft', 'h'],
    NEXT: ['ArrowRight', 'l'],

    // Unrated navigation
    PREV_UNRATED: ['Shift+k'],
    NEXT_UNRATED: ['Shift+j'],

    // Actions
    EXPORT: ['Ctrl+e', 'Meta+e'],
    TOGGLE_MARKDOWN: ['Ctrl+m', 'Meta+m'],
    SHOW_COMMENT: ['m'],
    SHOW_HELP: ['?'],
    CLOSE_MODAL: ['Escape'],

    // Categories (1-9)
    CATEGORIES: ['1', '2', '3', '4', '5', '6', '7', '8', '9']
};

export const UI_STATES = {
    LOADING: 'loading',
    READY: 'ready',
    ERROR: 'error',
    CLASSIFYING: 'classifying'
};

export const MODAL_TYPES = {
    HELP: 'help',
    COMMENT: 'comment'
};

export const CLASSIFICATION_STATUS = {
    UNCLASSIFIED: 'unclassified',
    CLASSIFIED: 'classified',
    SKIPPED: 'skipped'
};

export const ELEMENT_IDS = {
    // Main layout
    FILENAME: 'filename',
    PROGRESS: 'progress',
    CONTENT_DISPLAY: 'content-display',
    CLASSIFICATION_STATUS: 'classification-status',
    CATEGORY_BUTTONS: 'category-buttons',

    // Navigation
    PREV_BTN: 'prev-btn',
    NEXT_BTN: 'next-btn',
    NAV_PROGRESS: 'nav-progress',

    // Statistics
    STATS_CLASSIFIED: 'stats-classified',
    STATS_SKIPPED: 'stats-skipped',
    STATS_REMAINING: 'stats-remaining',

    // Help modal
    HELP_MODAL: 'help-modal',
    HELP_CLOSE: 'help-close',
    HELP_OVERLAY: 'help-overlay',

    // Comment system
    COMMENT_BTN: 'comment-btn',
    COMMENT_DISPLAY: 'comment-display',
    COMMENT_MODAL: 'comment-modal',
    COMMENT_CLOSE: 'comment-close',
    COMMENT_OVERLAY: 'comment-overlay',
    COMMENT_TEXT: 'comment-text',
    COMMENT_SAVE: 'comment-save',
    COMMENT_DELETE: 'comment-delete',
    COMMENT_CANCEL: 'comment-cancel',

    // Other
    MARKDOWN_INDICATOR: 'markdown-indicator'
};

export const CSS_CLASSES = {
    HIDDEN: 'hidden',
    ACTIVE: 'active',
    LOADING: 'loading',
    ERROR: 'error',
    SUCCESS: 'success',
    WARNING: 'warning'
};

export const API_ENDPOINTS = {
    STATE: '/api/state',
    ITEM: '/api/item',
    CLASSIFY: '/api/classify',
    COMMENT: '/api/comment',
    EXPORT: '/api/export'
};

export const MARKED_OPTIONS = {
    gfm: true,
    breaks: true,
    sanitize: false,
    smartLists: true,
    smartypants: false,
    xhtml: false
};`,
  'utils/domHelpers.js': `/**
 * DOM Helper utilities
 */

/**
 * Escape HTML to prevent XSS
 * @param {string} text - Text to escape
 * @returns {string} - Escaped HTML
 */
export function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * Get element by ID with error handling
 * @param {string} id - Element ID
 * @returns {HTMLElement} - The element
 * @throws {Error} - If element not found
 */
export function getElementById(id) {
    const element = document.getElementById(id);
    if (!element) {
        throw new Error(\`Element with ID '\${id}' not found\`);
    }
    return element;
}

/**
 * Get multiple elements by IDs
 * @param {string[]} ids - Array of element IDs
 * @returns {Object} - Object with element references
 */
export function getElementsByIds(ids) {
    const elements = {};
    ids.forEach(id => {
        elements[id] = getElementById(id);
    });
    return elements;
}

/**
 * Show/hide element
 * @param {HTMLElement} element - Element to show/hide
 * @param {boolean} visible - Whether to show the element
 */
export function setVisible(element, visible) {
    if (visible) {
        element.classList.remove('hidden');
    } else {
        element.classList.add('hidden');
    }
}

/**
 * Add event listener with cleanup
 * @param {HTMLElement} element - Element to add listener to
 * @param {string} event - Event type
 * @param {Function} handler - Event handler
 * @returns {Function} - Cleanup function
 */
export function addEventListener(element, event, handler) {
    element.addEventListener(event, handler);
    return () => element.removeEventListener(event, handler);
}

/**
 * Debounce function calls
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} - Debounced function
 */
export function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Create element with attributes and content
 * @param {string} tag - HTML tag name
 * @param {Object} attributes - Element attributes
 * @param {string|HTMLElement} content - Element content
 * @returns {HTMLElement} - Created element
 */
export function createElement(tag, attributes = {}, content = '') {
    const element = document.createElement(tag);

    Object.entries(attributes).forEach(([key, value]) => {
        if (key === 'className') {
            element.className = value;
        } else if (key === 'style' && typeof value === 'object') {
            Object.assign(element.style, value);
        } else {
            element.setAttribute(key, value);
        }
    });

    if (typeof content === 'string') {
        element.innerHTML = content;
    } else if (content instanceof HTMLElement) {
        element.appendChild(content);
    }

    return element;
}

/**
 * Wait for element to be visible
 * @param {string} selector - CSS selector
 * @param {number} timeout - Timeout in milliseconds
 * @returns {Promise<HTMLElement>} - Promise that resolves with the element
 */
export function waitForElement(selector, timeout = 5000) {
    return new Promise((resolve, reject) => {
        const element = document.querySelector(selector);
        if (element) {
            resolve(element);
            return;
        }

        const observer = new MutationObserver(() => {
            const element = document.querySelector(selector);
            if (element) {
                observer.disconnect();
                resolve(element);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        setTimeout(() => {
            observer.disconnect();
            reject(new Error(\`Element \${selector} not found within \${timeout}ms\`));
        }, timeout);
    });
}`,
};

export function getAsset(path: string): { content: string; mimeType: string } | null {
  // Remove leading slash and normalize path
  const normalizedPath = path.startsWith('/') ? path.slice(1) : path;

  // Handle root path
  let targetPath = normalizedPath;
  if (normalizedPath === '' || normalizedPath === 'index.html') {
    targetPath = 'index.html';
  }

  // Check if asset exists
  const content = EMBEDDED_ASSETS[targetPath];
  if (!content) {
    return null;
  }

  const ext = targetPath.includes('.') ?
    '.' + targetPath.split('.').pop() : '.js';

  return {
    content,
    mimeType: MIME_TYPES[ext] || 'text/plain',
  };
}
